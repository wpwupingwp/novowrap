#!/usr/bin/python3

from os import devnull
from pathlib import Path
from subprocess import run
from urllib.error import HTTPError
from urllib.request import urlopen
from zipfile import ZipFile
import argparse
import gzip
import logging

from Bio import SeqIO

from utils import get_fmt, get_ref, move
from validate_assembly import validate_main


# define logger
FMT = '%(asctime)s %(levelname)-8s %(message)s'
DATEFMT = '%H:%M:%S'
logging.basicConfig(format=FMT, datefmt=DATEFMT, level=logging.INFO)
log = logging.getLogger('novowrap')
try:
    import coloredlogs
    coloredlogs.install(level=logging.INFO, fmt=FMT, datefmt=DATEFMT)
except ImportError:
    pass


def get_novoplasty():
    """
    Ensure perl and novoplasty is available.
    Return novoplasty's path or None.
    """
    perl = run('perl -v', shell=True, stdout=open(devnull, 'w'))
    if perl.returncode != 0:
        log.critical('Please install Perl to run NOVOPlasty.')
        return None

    pl = list(Path('.').glob('NOVOPlasty*.pl'))
    if len(pl) != 0:
        return pl[0]
    _URL = 'https://github.com/ndierckx/NOVOPlasty/archive/NOVOPlasty3.6.zip'
    log.critical('Cannot find NOVOPlasty, try to download.')
    try:
        down = urlopen(_URL)
    except HTTPError:
        log.critical('Cannot download NOVOPlasty.')
        log.critical('Please manually download it from '
                     'http://github.com/ndierckx/NOVOPlasty')
        return None
    zip_file = Path('.') / 'NOVOPlasty3.6.zip'
    with open(zip_file, 'wb') as out:
        out.write(down.read())
    with ZipFile(zip_file, 'r') as z:
        # windows and linux both use "/"
        novoplasty = z.extract('NOVOPlasty-NOVOPlasty3.6/NOVOPlasty3.6.pl')
    zip_file.unlink()
    novoplasty = Path(novoplasty)
    log.info(f'Got {novoplasty.stem}.')
    return novoplasty


def parse_args():
    arg = argparse.ArgumentParser(
        formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    inputs = arg.add_argument_group('Input')
    inputs.add_argument('-i', dest='input', nargs='*',
                        help='single or pair-end input, fastq or gz format')
    inputs.add_argument('-l', dest='list', help='csv file for batch mode')
    inputs.add_argument('-p', dest='platform', choices=['illumina', 'ion'],
                        default='illumina', help='sequencing platform')
    inputs.add_argument('-insert_size',
                        help='insert size of sequencing library')
    inputs.add_argument('-seed', default='rbcL,psaB,psaC,rrn23,rrn23s',
                        help='seed gene, separated by comma')
    inputs.add_argument('-seed_file',
                        help='seed file, will overwrite "-seed" option')
    inputs.add_argument('-split', default=0, type=int,
                        help='reads to use, set to 0 to skip split')
    options = arg.add_argument_group('Option')
    options.add_argument('-kmer', choices=range(23, 40, 2), default=39,
                         type=int, help='kmer size')
    options.add_argument('-min', default=100000, type=int,
                         help='minimum genome size (KB)')
    options.add_argument('-max', default=200000, type=int,
                         help='maximum genome size (KB)')
    options.add_argument('-mem', default=30, type=int,
                         help='maximum memory (GB)')
    options.add_argument('-o', dest='out', help='output folder')
    options.add_argument('-debug', action='store_true', help='debug mode')
    reference = arg.add_argument_group('Reference')
    reference.add_argument('-ref',
                           help='reference file, should be "gb" format with '
                           'only one record')
    reference.add_argument('-taxon', default='Nicotiana tabacum',
                           help='Taxonomy name')
    return arg.parse_args()


def get_output(arg):
    """
    Get output folder.
    If exists, return None.
    Args:
        arg(NameSpace): arg generated by parse_args()
    Return:
        out(Path): output path
    """
    def _get_name(f, r):
        out_name = Path('Output').absolute()
        f = Path(f)
        r = Path(r)
        while f.suffix == r.suffix and f.suffix != '':
            f = f.with_suffix('')
            r = r.with_suffix('')
        same = 0
        idx = 0
        for i, j in zip(str(f), str(r)):
            if i == j:
                same += 1
            else:
                break
            idx += 1
        if same != 0:
            _ = list(str(f))
            _.pop(idx)
            strip_ = ''.join(_).rstrip('-_')
            if len(strip_) != 0:
                out_name = Path(strip_).absolute()
        return out_name

        return arg, False
    if arg.out is None:
        if arg.input is not None:
            if len(arg.input) == 2:
                out = _get_name(arg.input[0], arg.input[1])
            else:
                # for single file, directly remove all suffixes is dangerous
                out = Path(Path(arg.input[0]).stem).absolute()
        elif arg.list is not None:
            out = Path(Path(arg.list).stem).absolute()
    else:
        out = Path(arg.out).absolute()
    return out


def _read_table(arg):
    """
    Read table from given csv file.
    Columns of table:
        Input, Input(optional), Taxonomy
    Args:
        arg(NameSpace): arg generated from parse_args
        table(list): list of input items
    Return:
        inputs(list): [[f, r], taxon]
    """
    inputs = []
    with open(arg.list, 'r') as raw:
        for line in raw:
            try:
                f, r, taxon = line.strip().split(',')
            except IndexError:
                log.warning(f'Cannot parse the line : {line}')
                continue
            if r == '':
                f_r = [f, ]
            else:
                f_r = [f, r]
            inputs.append([f_r, taxon])
    return inputs


def split(raw, number, output):
    """
    Split reads of original file from the beginning.
    Args:
        raw(str or Path): input file, coulde be fastq or gz format
        number(int): number of reads to split
        output(Path): output folder
    Return:
        splitted(Path): splitted file, fastq format
        count(int): reads actually got
    """
    raw = Path(raw)
    fmt = get_fmt(raw)
    splitted = output / raw.with_suffix(f'.{number}').name
    splitted_handle = open(splitted, 'wb')
    if fmt == 'gz':
        raw_handle = gzip.open(raw)
    else:
        raw_handle = open(raw, 'rb')
    line = iter(raw_handle)
    count = 0
    while count < number:
        # four line one record
        try:
            splitted_handle.write(next(line))
            splitted_handle.write(next(line))
            splitted_handle.write(next(line))
            splitted_handle.write(next(line))
        except StopIteration:
            break
        count += 1
    raw_handle.close()
    splitted_handle.close()
    splitted = move(splitted, splitted.with_suffix(f'.{count}'))
    return splitted, count


def get_reads_len(filename):
    """
    Get reads length of fastq
    """
    fmt = get_fmt(filename)
    if fmt == 'gz':
        handle = gzip.open(filename)
    else:
        handle = open(filename, 'rb')
    handle.readline()
    seq = handle.readline()
    seq = seq.decode('utf-8').strip()
    length = len(seq)
    handle.close()
    log.debug(f'\tReads length: {length}')
    return length


def get_seed(ref, output, gene):
    """
    Use BarcodeFinder to get seed or reference sequence.
    Arg:
        ref(Path): reference chloroplast genome gb file, only contains one
        record
        output(Path): output folder
        gene(str): gene names, separated by comma
    Return:
        seeds(list): seed files list
    """
    seeds = {}
    genes = gene.split(',')
    gb = SeqIO.read(ref, 'gb')
    accession = gb.annotations['accessions'][0]
    organism = gb.annotations['organism'].replace(' ', '_')
    for feature in gb.features:
        if feature.type == 'gene' and 'gene' in feature.qualifiers:
            gene_name = feature.qualifiers['gene'][0]
            # for rrn23S
            if gene_name in genes or gene_name.lower() in genes:
                seq = feature.extract(gb)
                seed_file = output / f'{gene_name}.seed'
                with open(seed_file, 'w') as out:
                    out.write(f'>{gene_name}|{organism}|{accession}\n')
                    out.write(f'{seq.seq}\n')
                seeds[gene_name] = seed_file
    ordered_seeds = []
    for i in genes:
        if i in seeds:
            ordered_seeds.append(seeds[i])
    whole = output / 'whole.seed'
    SeqIO.convert(ref, 'gb', whole, 'fasta')
    ordered_seeds.append(whole)
    return ordered_seeds


def config(seed, arg):
    """
    Generate config file for NOVOPlasty.
    Arg:
        seed(Path): seed file
        arg(NameSpace): parameters user provided
    Return:
        config_file(Path): config file
    """
    if len(arg.input) == 2:
        f, r = arg.input
        m = ''
        s_or_p = 'PE'
    else:
        f = r = ''
        m = arg.input[0]
        s_or_p = 'SE'
    arg.reads_len = get_reads_len(arg.input[0])
    if arg.insert_size is None:
        arg.insert_size = arg.reads_len * 2 + 50
        log.info(f'The insert size is missing, use {arg.insert_size}.')
    config = f"""Project:
-----------------------
Project name          = {arg.out.name}
Type                  = chloro
Genome Range          = {arg.min}-{arg.max}
K-mer                 = {arg.kmer}
Max memory            = {arg.mem}
Extended log          = 1
Save assembled reads  = no
Seed Input            = {seed}
Reference sequence    =
Variance detection    = no
Chloroplast sequence  =

Dataset 1:
-----------------------
Read Length    = {arg.reads_len}
Insert size    = {arg.insert_size }
Platform       = {arg.platform}
Single/Paired  = {s_or_p}
Combined reads = {m}
Forward reads  = {f}
Reverse reads  = {r}

Optional:
-----------------------
Insert size auto      = yes
Insert Range          = 1.9
Insert Range strict   = 1.3
Use Quality Scores    = no
"""
    config_file = arg.raw / f'{seed.stem}_config.ini'
    with open(config_file, 'w') as out:
        out.write(config)
    return config_file


def organize_out(pwd, out, seed):
    """
    Organize NOVOPlasty output.
        log*: log file
        contigs_tmp*: temporary files
        Contigs*: contigs
        Merged*: merged contigs, may be circular or empty, contains options
        Option*: merged contigs, circular or incomplete circular
        Circularized*: circularized sequence
    Return fasta list.
    Arg:
        pwd(Path): current directory
        output(Path): output folder, contains "Temp", "Log", "Raw"
        seed(str): seed gene's name
    Return:
        contigs(list): contig files
        merged(list): merged files
        options(list): options files
        circularized(list): circularized files
    """
    def txt_to_fasta(old):
        """
        Convert NOVOPlasty-generated txt to standard fasta.
        """
        clean = []
        record = []
        begin = False
        with open(old, 'r') as raw:
            for line in raw:
                if line.startswith('>'):
                    clean.extend(record)
                    record = []
                    begin = True
                if line.startswith(' ') or len(line.strip()) == 0:
                    begin = False
                    clean.extend(record)
                    record = []
                if begin:
                    record.append(line)
        clean.extend(record)
        new = Path(old).with_suffix('.fasta')
        with open(new, 'w') as out:
            for line in clean:
                out.write(line.replace('*', ''))
        return new

    for i in pwd.glob('contigs_tmp_*'):
        move(i, out/'Temp'/i.with_name(f'{i.stem}-{seed}{i.suffix}').name)
    for i in pwd.glob('log_*.txt'):
        move(i, out/'Log'/i.with_name('NOVOPlasty-'+i.name).name)
    contigs = []
    for i in pwd.glob('Contigs_*'):
        i = move(i, out/'Raw'/i.with_name(f'{i.stem}-{seed}{i.suffix}').name)
        contigs.append(i)
    merged = []
    for i in pwd.glob('Merged_contigs_*'):
        i = move(i, out/'Raw'/i.with_name(f'{i.stem}-{seed}{i.suffix}').name)
        fasta = txt_to_fasta(i)
        fasta = move(fasta, out/'Raw'/fasta.name)
        merged.append(fasta)
    options = []
    for i in pwd.glob('Option_*'):
        i = move(i, out/'Raw'/i.with_name(f'{i.stem}-{seed}{i.suffix}').name)
        options.append(i)
    circularized = []
    for i in pwd.glob('Circularized_assembly*'):
        i = move(i, out/'Raw'/i.with_name(f'{i.stem}-{seed}{i.suffix}').name)
        circularized.append(i)
    return circularized, options, merged, contigs


def assembly(arg, novoplasty):
    """
    Assembly input file by wrapping NOVOPlasty.
    Return -1 if failed.
    """
    log.info('')
    for i in arg.input:
        test = Path(i)
        # arg.list may contains invalid file
        if not test.exists():
            log.critical(f'Cannot find input file {i}')
            return -1
        else:
            log.info(f'Input file: {i}')
    log.info(f'Minimum genome size: {arg.min}')
    log.info(f'Maximum genome size: {arg.max}')
    log.info(f'Taxonomy: {arg.taxon}')
    log.info(f'Output folder: {arg.out}')
    if arg.split != 0:
        log.info(f'Split {arg.split} pairs of reads for assembly')
        splitted = []
        for raw in arg.input:
            new, count = split(raw, arg.split, arg.tmp)
            if count < arg.split:
                log.warning(f'Want {arg.split} reads, acutally got {count}.')
            splitted.append(new)
        arg.input = splitted
    # get ref
    if arg.ref is not None:
        if get_fmt(arg.ref) != 'gb':
            log.critical('Reference file should be genbank format, '
                         'but {arg.ref} is not.')
            return -1
        ref = Path(arg.ref)
        ref = move(ref, arg.tmp/ref, copy=True)
    else:
        log.info('Try to get reference from NCBI Genbank.')
        ref = get_ref(arg.taxon)
        if ref is None:
            log.critical('Cannot get reference.')
            return -1
        else:
            log.info(f'Got {ref.stem}.')
            ref = move(ref, arg.tmp/ref)
    # get seed
    seeds = []
    if arg.seed_file is not None:
        seeds.append(Path(arg.seed_file))
    seeds.extend(get_seed(ref, arg.raw, arg.seed))
    if len(seeds) == 0:
        log.critical('Cannot get seeds!')
        return -1
    csv_files = []
    success = False
    for seed in seeds:
        log.info(f'Use {seed.stem} as seed.')
        config_file = config(seed, arg)
        log.info('Call NOVOPlasty...')
        run(f'perl {novoplasty} -c {config_file}', shell=True)
        # novoplasty use current folder as output folder
        circularized, options, merged, contigs = organize_out(
            Path().cwd(), arg.out, seed.stem)
        if len(circularized) == 0 and len(options) == 0 and len(merged) == 0:
            log.warning(f'Assembled with {seed.stem} failed.')
            continue
        validated = []
        # validate merged or not?
        log.info('Validate assembly results.')
        # for i in (*circularized, *options, *merged):
        for i in (*circularized, *options):
            log.info('')
            arg_str = f'{i} -ref {ref} -seed {seed.stem} -o {arg.out}'
            validate_file, report = validate_main(arg_str)
            validated.extend(validate_file)
            if report not in csv_files:
                csv_files.append(report)
        if len(validated) != 0:
            success = True
            break
        else:
            log.warning('No records passed validation.')
        if not success:
            log.critical(f'Assembly with {seed.stem} failed.')
    log.info('')
    return 0


def main():
    log.info('Welcome to novowrap.')
    # check before run
    novoplasty = get_novoplasty()
    if novoplasty is None:
        return -1
    arg = parse_args()
    if arg.list is None:
        if arg.input is None:
            log.critical('Input is empty.')
            return -1
        elif len(arg.input) > 2:
            log.critical('Only accept one or two input file(s).')
            return -1
    arg.out = get_output(arg)
    if arg.out is None:
        return -1
    elif arg.out.exists():
        log.critical(f'Output folder {arg.out.name} exists.')
        return -1
    else:
        arg.out.mkdir()
    arg.log = arg.out / 'Log'
    arg.log.mkdir()
    arg.raw = arg.out / 'Raw'
    arg.raw.mkdir()
    arg.tmp = arg.out / 'Temp'
    arg.tmp.mkdir()
    # log to file
    log_file_handler = logging.FileHandler(str(arg.log/'Log.txt'))
    log_file_handler.setLevel(logging.DEBUG)
    Formatter = logging.Formatter(FMT, DATEFMT)
    log_file_handler.setFormatter(Formatter)
    log.addHandler(log_file_handler)
    # start
    if arg.list is None:
        assembly(arg, novoplasty)
    else:
        table = _read_table(arg)
        for i in table:
            arg.input, arg.taxon = i
            assembly(arg, novoplasty)
    log.info('Bye.')
    return


if __name__ == '__main__':
    main()
